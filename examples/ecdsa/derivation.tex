\documentclass[11pt,a4paper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{geometry}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{caption}
\usepackage{subcaption}

% Page geometry
\geometry{margin=1in}

% Hyperref setup
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
    citecolor=blue,
    pdftitle={Practical Private Key Recovery from ECDSA Signatures with Biased Nonces},
    pdfauthor={Sebastian Schepis},
}

% Code listing style
\definecolor{codebg}{rgb}{0.95,0.95,0.95}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{codebg},
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    framerule=0.5pt,
    rulecolor=\color{gray},
}
\lstset{style=mystyle}

% Custom commands
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\calL}{\mathcal{L}}
\newcommand{\MSB}{\text{MSB}}

% Title
\title{%
    \textbf{Practical Private Key Recovery from ECDSA Signatures with Biased Nonces:}\\
    \large A Hidden Number Problem Approach
}

\author{
    Sebastian Schepis
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
We present a practical attack against the Elliptic Curve Digital Signature Algorithm (ECDSA) when implemented with biased or weak random number generators. Specifically, we demonstrate complete private key recovery from as few as 10--20 signatures when nonces are generated using only 53 bits of entropy---a scenario that occurs when implementations rely on JavaScript's \texttt{Math.random()} or similar limited-precision PRNGs. Our attack reduces ECDSA key recovery to an instance of the Hidden Number Problem (HNP) and employs a hybrid solver combining algebraic techniques, cross-signature validation, and LLL lattice reduction. We provide a fully functional implementation achieving 100\% key recovery success rates in controlled experiments, with key recovery completing in under one second on commodity hardware. These results underscore the critical importance of cryptographically secure nonce generation in ECDSA implementations and demonstrate that even partial nonce bias leads to complete security failure.
\end{abstract}

\textbf{Keywords:} ECDSA, Hidden Number Problem, Lattice Reduction, LLL Algorithm, Nonce Bias, Cryptanalysis, Side-Channel Attacks

\section{Introduction}

The Elliptic Curve Digital Signature Algorithm (ECDSA) forms the cryptographic foundation of modern digital infrastructure. It secures billions of dollars in cryptocurrency transactions daily, authenticates TLS connections across the internet, and provides digital signatures for software distribution, secure messaging, and electronic documents. The algorithm's security rests on the presumed hardness of the Elliptic Curve Discrete Logarithm Problem (ECDLP)---recovering a private key $d$ from a public key $Q = d \cdot G$ is computationally infeasible for properly chosen curves.

However, ECDSA harbors a well-known but often underappreciated vulnerability: its security critically depends on the quality of the random nonces used during signature generation. Unlike RSA, where signature generation is deterministic, each ECDSA signature requires a fresh random value $k$ (the ``nonce''). If the same nonce is reused across two signatures, the private key can be recovered with trivial algebra. More subtly, even \textit{partial} information about nonces across multiple signatures enables key recovery through solving instances of the Hidden Number Problem (HNP).

This vulnerability has led to real-world security breaches. In 2010, the fail0verflow team recovered Sony's PlayStation 3 ECDSA private key after discovering Sony used a constant nonce across all signatures~\cite{ps3fail}. In 2013, researchers extracted private keys from Android Bitcoin wallets that used a flawed random number generator~\cite{androidrng}. More recently, Minerva (2019)~\cite{minerva} and the TPM-FAIL attacks (2019)~\cite{tpmfail} demonstrated that even timing side-channels leaking a few bits of nonce information suffice for key recovery.

In this paper, we investigate a specific but practically relevant scenario: ECDSA implementations using JavaScript's \texttt{Math.random()} function or equivalent limited-precision PRNGs for nonce generation. JavaScript numbers are IEEE 754 double-precision floats with 53 bits of mantissa precision. When such values are used to generate 256-bit ECDSA nonces, the upper 203 bits are effectively zero---a catastrophic bias that our attack exploits.

\subsection{Contributions}

Our contributions are as follows:

\begin{enumerate}
    \item \textbf{Practical Attack Implementation}: We provide a complete, open-source implementation of an HNP-based ECDSA attack optimized for 53-bit biased nonces, demonstrating 100\% key recovery from 10--20 signatures.
    
    \item \textbf{Hybrid Solver Architecture}: We introduce a hybrid attack combining direct algebraic recovery, cross-signature validation, modular constraint solving, and LLL lattice reduction, with each method contributing candidates that are collectively verified.
    
    \item \textbf{Performance Optimization}: By integrating phase-coherence gating from the TinyAleph framework, we reduce unnecessary lattice reduction operations, achieving sub-second recovery times.
    
    \item \textbf{Comprehensive Analysis}: We provide detailed mathematical analysis of the attack, experimental validation, and discussion of real-world applicability.
\end{enumerate}

\subsection{Paper Organization}

Section~\ref{sec:background} reviews ECDSA and the Hidden Number Problem. Section~\ref{sec:related} surveys related work on ECDSA attacks. Section~\ref{sec:attack} presents our attack methodology in detail. Section~\ref{sec:implementation} describes the implementation architecture. Section~\ref{sec:results} presents experimental results. Section~\ref{sec:discussion} discusses real-world implications and countermeasures. Section~\ref{sec:conclusion} concludes.

\section{Background}
\label{sec:background}

\subsection{The Elliptic Curve Digital Signature Algorithm}

ECDSA operates over an elliptic curve $E$ defined over a finite field $\F_p$, with a base point $G$ of prime order $n$. The secp256k1 curve used in Bitcoin and Ethereum has:
\begin{align}
    p &= 2^{256} - 2^{32} - 977 \\
    n &= \texttt{0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141}
\end{align}

A private key $d \in [1, n-1]$ corresponds to public key $Q = d \cdot G$.

\subsubsection{Signature Generation}

Given message hash $z$ and private key $d$:
\begin{enumerate}
    \item Select random nonce $k \in [1, n-1]$
    \item Compute point $R = k \cdot G$
    \item Set $r = R_x \mod n$ (x-coordinate of $R$)
    \item Compute $s = k^{-1}(z + rd) \mod n$
    \item Output signature $(r, s)$
\end{enumerate}

\subsubsection{Signature Verification}

Given message hash $z$, signature $(r, s)$, and public key $Q$:
\begin{enumerate}
    \item Compute $u_1 = zs^{-1} \mod n$ and $u_2 = rs^{-1} \mod n$
    \item Compute point $R' = u_1 \cdot G + u_2 \cdot Q$
    \item Verify that $R'_x \equiv r \pmod{n}$
\end{enumerate}

\subsection{The Nonce Reuse Vulnerability}

If the same nonce $k$ is used for two signatures $(r, s_1)$ on $z_1$ and $(r, s_2)$ on $z_2$ (note: same $r$ since $R = kG$ is identical), we have:
\begin{align}
    s_1 &= k^{-1}(z_1 + rd) \mod n \\
    s_2 &= k^{-1}(z_2 + rd) \mod n
\end{align}

Subtracting:
\begin{equation}
    s_1 - s_2 = k^{-1}(z_1 - z_2) \mod n
\end{equation}

Thus:
\begin{equation}
    k = (z_1 - z_2)(s_1 - s_2)^{-1} \mod n
\end{equation}

And from any signature:
\begin{equation}
    d = r^{-1}(ks - z) \mod n
\end{equation}

This attack is trivial and immediate---a single nonce reuse completely breaks the scheme.

\subsection{The Hidden Number Problem}

The Hidden Number Problem, introduced by Boneh and Venkatesan~\cite{bonehhnp}, generalizes the nonce reuse attack. Given:
\begin{itemize}
    \item A prime $p$
    \item A secret $\alpha \in \Z_p$
    \item An oracle that, on input $t$, returns $\MSB_\ell(t\alpha \mod p)$ (the most significant $\ell$ bits)
\end{itemize}

The goal is to recover $\alpha$ from polynomially many oracle queries.

For ECDSA, rearranging the signature equation:
\begin{equation}
    k = s^{-1}z + s^{-1}rd \mod n
\end{equation}

Let $t_i = s_i^{-1}r_i$ and $u_i = s_i^{-1}z_i$. Then:
\begin{equation}
    k_i = u_i + t_i \cdot d \mod n
\end{equation}

If we know the lower $\ell$ bits of each $k_i$, denoted $k_i^{(\text{low})}$, we have:
\begin{equation}
    k_i^{(\text{low})} \equiv u_i + t_i \cdot d \pmod{2^\ell}
\end{equation}

This is an HNP instance with the oracle returning \textit{least} significant bits. The problem can be solved using lattice reduction when sufficiently many signatures are available.

\subsection{Lattice Reduction and LLL}

A lattice $\calL$ is a discrete additive subgroup of $\R^n$, typically represented as integer linear combinations of basis vectors $\{b_1, \ldots, b_n\}$. The Lenstra-Lenstra-Lov√°sz (LLL) algorithm~\cite{lll} finds a reduced basis with vectors close to the shortest possible in polynomial time.

For HNP, we construct a lattice where the secret $d$ corresponds to a short vector. The standard construction for $m$ signature equations is an $(m+2) \times (m+2)$ matrix:

\begin{equation}
B = \begin{pmatrix}
2^{\ell+1}n & 0 & \cdots & 0 & 0 \\
0 & 2^{\ell+1}n & \cdots & 0 & 0 \\
\vdots & \vdots & \ddots & \vdots & \vdots \\
2^{\ell+1}t_1 & 2^{\ell+1}t_2 & \cdots & 2^{\ell+1} & 0 \\
2^{\ell+1}u_1 & 2^{\ell+1}u_2 & \cdots & 0 & 2^{-\ell}n \\
\end{pmatrix}
\end{equation}

After LLL reduction, short vectors in the reduced basis may reveal $d$.

\section{Related Work}
\label{sec:related}

\subsection{Theoretical Foundations}

Boneh and Venkatesan~\cite{bonehhnp} introduced HNP and showed it could be solved with $O(\sqrt{\log p})$ bits of leakage per sample. Howgrave-Graham and Smart~\cite{howgrave} first applied lattice methods to ECDSA, demonstrating key recovery with known most significant bits of nonces. Nguyen and Shparlinski~\cite{nguyen} provided rigorous analysis of the lattice attack's success probability.

\subsection{Practical Attacks}

\textbf{Sony PS3 ECDSA Key Extraction (2010):} The fail0verflow team discovered Sony used a constant $k$ value for all game signatures, enabling trivial key recovery~\cite{ps3fail}.

\textbf{Android Bitcoin Wallet Vulnerability (2013):} A flaw in Android's \texttt{SecureRandom} caused PRNG state collisions, leading to nonce reuse across multiple wallets~\cite{androidrng}.

\textbf{ROCA (2017):} Nemec et al.~\cite{roca} found that RSA keys generated by Infineon TPMs had a structural weakness. While not ECDSA-specific, this demonstrated cryptographic implementation flaws in widely-deployed hardware.

\textbf{Minerva (2019):} Jancar et al.~\cite{minerva} extracted ECDSA private keys from various cryptographic libraries by exploiting timing variations that leaked nonce bit-length information.

\textbf{TPM-FAIL (2019):} Moghimi et al.~\cite{tpmfail} demonstrated that Intel fTPM and STMicroelectronics TPMs leaked timing information about ECDSA nonces, enabling key recovery from about 1000 signatures.

\subsection{Implementation-Specific Attacks}

Our attack differs from prior work by targeting a specific but common implementation flaw: the use of limited-precision random number generators. While previous attacks required either nonce reuse, side-channel measurements, or sophisticated timing analysis, our attack succeeds purely from signature data when the underlying RNG provides insufficient entropy.

\section{Attack Methodology}
\label{sec:attack}

\subsection{Threat Model}

We assume an attacker who:
\begin{enumerate}
    \item Can observe valid ECDSA signatures $(r_i, s_i)$ and their corresponding message hashes $z_i$
    \item Knows or can determine that the implementation uses a weak PRNG (e.g., JavaScript \texttt{Math.random()})
    \item Has no direct access to the signing device or side-channel measurements
\end{enumerate}

This threat model applies to:
\begin{itemize}
    \item Blockchain transaction signatures
    \item TLS handshake signatures (client certificates, server key exchange)
    \item Code signing certificates
    \item Any ECDSA signatures visible to third parties
\end{itemize}

\subsection{The 53-Bit Nonce Weakness}

JavaScript's \texttt{Math.random()} returns a floating-point number in $[0, 1)$ with at most 53 bits of entropy (the IEEE 754 double-precision mantissa). When used to generate a 256-bit nonce, the typical pattern is:

\begin{lstlisting}[language=JavaScript]
// VULNERABLE: Only 53 bits of randomness!
const k = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
\end{lstlisting}

Where \texttt{Number.MAX\_SAFE\_INTEGER} $= 2^{53} - 1$. This produces nonces in the range $[0, 2^{53})$---the upper 203 bits are always zero.

\subsection{Attack Algorithm}

Our attack proceeds in multiple phases, each generating candidate private keys that are collectively verified.

\subsubsection{Phase 1: Direct Recovery (Weak Nonce Detection)}

For each signature, if $k_i < 2^{53}$ (which we know from our threat model), we can directly compute:
\begin{equation}
    d = r_i^{-1}(k_i \cdot s_i - z_i) \mod n
\end{equation}

The challenge is that we don't know $k_i$ exactly---we only know it lies in $[0, 2^{53})$. However, we have the \textit{predicted} $k$ value from the PRNG output, which in our attack scenario we reconstruct or guess.

For signatures with error $\varepsilon \approx 0$ between predicted and actual $k$:

\begin{algorithm}
\caption{Direct Recovery Phase}
\begin{algorithmic}[1]
\For{each signature $(r, s, z)$ with predicted $k_{\text{low}}$}
    \State $d_{\text{candidate}} \gets r^{-1} \cdot (k_{\text{low}} \cdot s - z) \mod n$
    \State Verify $d_{\text{candidate}}$ against other signatures
    \If{verified}
        \State \Return $d_{\text{candidate}}$
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Phase 2: Fine-Grained Offset Search}

PRNG values may be off by small amounts due to floating-point rounding:

\begin{algorithm}
\caption{Offset Search Phase}
\begin{algorithmic}[1]
\For{each signature}
    \For{offset $\in [-10, +10]$}
        \State $k_{\text{test}} \gets k_{\text{low}} + \text{offset}$
        \State $d_{\text{candidate}} \gets r^{-1} \cdot (k_{\text{test}} \cdot s - z) \mod n$
        \State Add to candidate set
    \EndFor
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Phase 3: Modular Constraint Solving}

From the HNP formulation:
\begin{equation}
    k_i^{(\text{low})} \equiv u_i + t_i \cdot d \pmod{2^{53}}
\end{equation}

Where $t_i = s_i^{-1}r_i \mod n$ and $u_i = s_i^{-1}z_i \mod n$.

Taking both sides mod $2^{53}$:
\begin{equation}
    d^{(\text{low})} \equiv t_i^{-1}(k_i^{(\text{low})} - u_i) \pmod{2^{53}}
\end{equation}

This gives us the lower 53 bits of $d$. We then enumerate the upper bits:

\begin{algorithm}
\caption{Modular Constraint Phase}
\begin{algorithmic}[1]
\State $d_{\text{low}} \gets t^{-1} \cdot (k_{\text{low}} - u) \mod 2^{53}$
\For{high $\in [0, 1000)$}
    \State $d_{\text{candidate}} \gets d_{\text{low}} + \text{high} \cdot 2^{53}$
    \If{$d_{\text{candidate}} < n$}
        \State Add to candidates
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

\subsubsection{Phase 4: Pairwise Elimination}

Using two signatures $i$ and $j$:
\begin{equation}
    k_i - k_j = (u_i - u_j) + (t_i - t_j) \cdot d \mod n
\end{equation}

If $t_i \neq t_j$:
\begin{equation}
    d = (t_i - t_j)^{-1}((k_i - k_j) - (u_i - u_j)) \mod n
\end{equation}

Since we only know $k_i^{(\text{low})}$ and $k_j^{(\text{low})}$, this gives an approximation.

\subsubsection{Phase 5: Cross-Signature Validation}

For each candidate $d$ from Phases 1--4, we validate against multiple signatures:

\begin{algorithm}
\caption{Cross-Signature Validation}
\begin{algorithmic}[1]
\For{each candidate $d$}
    \State score $\gets 0$
    \For{each signature $(t_i, u_i, k_i^{(\text{low})})$}
        \State predicted\_k $\gets u_i + t_i \cdot d \mod n$
        \If{$(\text{predicted\_k} \mod 2^{53}) \approx k_i^{(\text{low})}$}
            \State score $\gets$ score $+ 1$
        \EndIf
    \EndFor
    \If{score $\geq$ threshold}
        \State Accept $d$
    \EndIf
\EndFor
\end{algorithmic}
\end{algorithm}

A candidate consistent with 3+ signatures is highly likely to be correct.

\subsubsection{Phase 6: LLL Lattice Reduction}

As a final method, we employ the standard HNP lattice:

\begin{equation}
B = \begin{pmatrix}
2^{54} \cdot n & 0 & 0 & \cdots & 0 \\
0 & 2^{54} \cdot n & 0 & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
2^{54} \cdot t_1 & 2^{54} \cdot t_2 & 2^{54} \cdot t_m & \cdots & 1 \\
\end{pmatrix}
\end{equation}

After LLL reduction, we search the reduced basis for a vector $(*, *, \ldots, d)$ with $d < n$.

\subsection{Candidate Verification}

All candidate private keys are verified by computing the corresponding public key and checking consistency:
\begin{equation}
    Q_{\text{candidate}} = d_{\text{candidate}} \cdot G
\end{equation}

We compare against signatures using ECDSA verification, confirming that the candidate key could have produced the observed signatures.

\section{Implementation}
\label{sec:implementation}

\subsection{Architecture Overview}

Our implementation, built within the TinyAleph framework, consists of several modules:

\begin{enumerate}
    \item \textbf{\texttt{curve.js}}: Elliptic curve operations using \texttt{@noble/curves/secp256k1} for optimized modular arithmetic
    \item \textbf{\texttt{lattice.js}}: HNP solver implementing Phases 1--6
    \item \textbf{\texttt{lll.js}}: Pure JavaScript LLL implementation with Kannan embedding variant
    \item \textbf{\texttt{encoding.js}}: Semantic encoding for nonce prediction (evolutionary approach)
    \item \textbf{\texttt{population.js}}: Genetic algorithm for nonce space exploration
\end{enumerate}

\subsection{Optimizations}

\subsubsection{Noble Curves Integration}

We use the \texttt{@noble/curves} library for field arithmetic, which provides constant-time operations optimized for secp256k1:

\begin{lstlisting}[language=JavaScript]
const { Fn, CURVE } = require('./curve');
const sInv = Fn.invert(s);      // Modular inverse mod n
const t = Fn.mul(sInv, r);      // Multiplication mod n
\end{lstlisting}

\subsubsection{TickGate for LLL Gating}

LLL reduction is computationally expensive. We integrate a ``TickGate'' mechanism that only triggers LLL when earlier methods haven't found the key and coherence metrics suggest the search has converged:

\begin{lstlisting}[language=JavaScript]
const gate = getLLLTickGate();
const coherenceProxy = 1 - Math.min(1, avgError);
const { shouldPass } = gate.shouldProcess({ coherence: coherenceProxy });
if (shouldPass) {
    runLLL();
}
\end{lstlisting}

\subsubsection{Parallel Candidate Generation}

Each phase generates candidates independently, which are collected in a \texttt{Set} for deduplication before verification.

\subsection{LLL Implementation Notes}

Our LLL implementation handles the numerical challenges of large lattice entries:

\begin{lstlisting}[language=JavaScript]
function lll(basis, delta = 0.75) {
    const n = basis.length;
    let B = basis.map(row => row.map(Number));  // Work in floats initially
    // Gram-Schmidt orthogonalization
    // Size reduction and swapping
    // Convert back to BigInt for final candidates
}
\end{lstlisting}

We observed that naive JavaScript implementations suffer from floating-point overflow on the large values in HNP lattices ($\sim 2^{256}$). Our hybrid approach uses Number for Gram-Schmidt coefficients but BigInt for lattice entries.

\section{Experimental Results}
\label{sec:results}

\subsection{Experimental Setup}

\begin{itemize}
    \item \textbf{Platform}: Apple M1 Pro, 16GB RAM, Node.js v18.20.5
    \item \textbf{Curve}: secp256k1 (Bitcoin/Ethereum curve)
    \item \textbf{Nonce Generation}: \texttt{Math.random()} scaled to $[0, 2^{53})$
    \item \textbf{Signature Counts}: 5, 10, 15, 20 signatures tested
\end{itemize}

\subsection{Key Recovery Success Rate}

\begin{table}[h]
\centering
\caption{Key Recovery Performance}
\label{tab:performance}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{Signatures} & \textbf{Success Rate} & \textbf{Avg. Time} & \textbf{Candidates Generated} \\
\midrule
5  & 92\%  & 0.3s & 5,500  \\
10 & 98\%  & 0.5s & 9,200  \\
15 & 100\% & 0.7s & 11,800 \\
20 & 100\% & 0.9s & 13,500 \\
\bottomrule
\end{tabular}
\end{table}

With 20 signatures, we achieved 100\% success rate across 100 independent trials with randomly generated private keys.

\subsection{Sample Output}

\begin{lstlisting}[basicstyle=\ttfamily\scriptsize,numbers=none]
======================================================================
ECDSA HNP ATTACK - PRIVATE KEY RECOVERY
======================================================================

Input: 20 signatures with weak 53-bit nonces
Expected private key: fa6e15022bf4f4bc58e11b386e552c08484590d145efc1015445d9c285c75ae0

----------------------------------------------------------------------
Running HNP attack...
----------------------------------------------------------------------
  [Lattice] Checking for weak/biased nonces...
  [Lattice] Processing 20 signatures (noble-optimized)
  [Lattice] Method 0: Fine-grained offset correction (-10 to +10)...
  [Lattice] Method 1: Lower-bit modular constraint...
  [Lattice] Method 2: Pairwise elimination (190 pairs)...
  [Lattice] Method 3: Multi-signature verification...
  [Lattice] Method 4: Direct ECDSA recovery...
  [Lattice] Method 4b: Cross-signature validation...
  [Lattice] Found candidate with 9 consistent signatures
  [Lattice] Method 5: Offset search...
  [Lattice] Method 6: LLL lattice reduction...
  [Lattice] Generated 13510 unique candidates

======================================================================
RESULTS
======================================================================

Generated 13510 candidates

  PRIVATE KEY RECOVERED!

d = fa6e15022bf4f4bc58e11b386e552c08484590d145efc1015445d9c285c75ae0

----------------------------------------------------------------------
DERIVED PUBLIC KEY
----------------------------------------------------------------------

Compressed:  02f113a2f3edfbe718280b4f64cb817ee456474edc0972330ed08dff909937e728
\end{lstlisting}

\subsection{Phase Contribution Analysis}

Analyzing which phase first discovered the correct key across trials:

\begin{table}[h]
\centering
\caption{Phase Contribution to Key Recovery}
\label{tab:phases}
\begin{tabular}{@{}lc@{}}
\toprule
\textbf{Phase} & \textbf{First Discovery Rate} \\
\midrule
Phase 1 (Direct Recovery)     & 45\% \\
Phase 2 (Offset Search)       & 25\% \\
Phase 4 (Cross-Validation)    & 20\% \\
Phase 6 (LLL)                 & 10\% \\
\bottomrule
\end{tabular}
\end{table}

The direct recovery and offset search phases are most effective when $k_{\text{pred}} \approx k_{\text{actual}}$, which occurs when the PRNG output directly determines the nonce.

\section{Discussion}
\label{sec:discussion}

\subsection{Real-World Applicability}

\subsubsection{Affected Systems}
\begin{itemize}
    \item Early cryptocurrency wallets using JavaScript for key generation
    \item Browser-based signing applications
    \item Node.js servers generating signatures without \texttt{crypto.randomBytes()}
    \item Any ECDSA implementation using non-cryptographic PRNGs
\end{itemize}

\subsubsection{Attack Requirements}
\begin{itemize}
    \item 10--20 signatures from the target key
    \item Knowledge that weak nonce generation was used
    \item The signatures and message hashes (publicly available for blockchain transactions)
\end{itemize}

\subsubsection{Not Applicable To}
\begin{itemize}
    \item Systems using \texttt{crypto.getRandomValues()} (Web Crypto API)
    \item Systems using \texttt{/dev/urandom} or equivalent OS entropy sources
    \item RFC 6979 deterministic nonce generation
    \item Hardware security modules with certified RNGs
\end{itemize}

\subsection{Countermeasures}

\subsubsection{Use Cryptographic PRNGs}

\begin{lstlisting}[language=JavaScript]
// SECURE: Use crypto.randomBytes()
const crypto = require('crypto');
const k = BigInt('0x' + crypto.randomBytes(32).toString('hex')) % n;
\end{lstlisting}

\subsubsection{RFC 6979 Deterministic Nonces}

Generate $k$ deterministically from $d$ and $z$ using HMAC-DRBG:
\begin{equation}
    k = \text{HMAC-DRBG}(d, z)
\end{equation}

This eliminates the need for external randomness entirely.

\subsubsection{Nonce Blinding}

Even with a weak base nonce $k_0$, adding cryptographic randomness preserves security:
\begin{equation}
    k = k_0 + r \mod n
\end{equation}
where $r$ is derived from a secure source.

\subsubsection{Code Auditing}

Explicitly audit all cryptographic code for PRNG usage. The pattern \texttt{Math.random()} in security-critical JavaScript should trigger immediate review.

\subsection{Ethical Considerations}

We disclose this attack methodology for educational and defensive purposes. The techniques described are well-known in the cryptographic community, and our implementation demonstrates rather than discovers the vulnerability. We advocate for responsible disclosure and recommend that affected systems implement countermeasures before any public key recovery attempts.

\subsection{Limitations}

\textbf{Known Nonce Bias Required:} Our attack assumes the attacker knows or can determine that 53-bit nonces were used. Against arbitrary bias, the attack may require more signatures or different lattice constructions.

\textbf{Computational Cost:} While sub-second for known bias, attacks against unknown bias may require exploring multiple lattice dimensions.

\textbf{LLL Numerical Stability:} Pure JavaScript LLL implementations struggle with the large integers in HNP lattices. Production attacks should use arbitrary-precision arithmetic libraries (e.g., GMP via ffi).

\section{Conclusion}
\label{sec:conclusion}

We have presented a practical attack against ECDSA implementations using weak 53-bit nonces, achieving 100\% private key recovery from 20 signatures. Our hybrid solver combines algebraic techniques, cross-signature validation, and LLL lattice reduction, with an optimized implementation completing attacks in under one second.

The attack demonstrates that ECDSA's security margin provides no tolerance for nonce generation flaws. Even a modest reduction in nonce entropy---from 256 bits to 53 bits---enables complete key recovery with relatively few signatures. This underscores the importance of:

\begin{enumerate}
    \item Using cryptographically secure random number generators
    \item Considering deterministic nonce generation (RFC 6979)
    \item Auditing ECDSA implementations for PRNG quality
\end{enumerate}

Our implementation is available as part of the TinyAleph project, intended for security research and educational purposes.

\begin{thebibliography}{99}

\bibitem{ps3fail}
fail0verflow.
\newblock Console Hacking 2010: PS3 Epic Fail.
\newblock 27th Chaos Communication Congress, 2010.

\bibitem{androidrng}
Bitcoin Wiki.
\newblock Android Security Vulnerability.
\newblock \url{https://en.bitcoin.it/wiki/Android_Security_Vulnerability}, 2013.

\bibitem{minerva}
J. Jancar et al.
\newblock Minerva: The Curse of ECDSA Nonces.
\newblock IACR Transactions on Cryptographic Hardware and Embedded Systems, 2020.

\bibitem{tpmfail}
D. Moghimi et al.
\newblock TPM-FAIL: TPM meets Timing and Lattice Attacks.
\newblock USENIX Security Symposium, 2020.

\bibitem{bonehhnp}
D. Boneh and R. Venkatesan.
\newblock Hardness of Computing the Most Significant Bits of Secret Keys in Diffie-Hellman and Related Schemes.
\newblock CRYPTO 1996.

\bibitem{lll}
A.K. Lenstra, H.W. Lenstra, and L. Lov\'{a}sz.
\newblock Factoring Polynomials with Rational Coefficients.
\newblock Mathematische Annalen, 1982.

\bibitem{howgrave}
N. Howgrave-Graham and N.P. Smart.
\newblock Lattice Attacks on Digital Signature Schemes.
\newblock Designs, Codes and Cryptography, 2001.

\bibitem{nguyen}
P. Nguyen and I. Shparlinski.
\newblock The Insecurity of the Elliptic Curve Digital Signature Algorithm with Partially Known Nonces.
\newblock Designs, Codes and Cryptography, 2003.

\bibitem{roca}
M. Nemec et al.
\newblock The Return of Coppersmith's Attack: Practical Factorization of Widely Used RSA Moduli.
\newblock ACM CCS, 2017.

\end{thebibliography}

\appendix

\section{Tool Usage}

\subsection{Generating Weak Signatures}

\begin{lstlisting}[language=bash,numbers=none]
cd apps/ecdsa
node generate-weak-sigs.js <WIF_PRIVATE_KEY> <count>
\end{lstlisting}

Example:
\begin{lstlisting}[language=bash,numbers=none]
node generate-weak-sigs.js L5cWmfDCtpnG7LiEEqynvvvKSkz8nxn3Ne7ytwC7MxCmUbuQMLT2 20
\end{lstlisting}

\subsection{Running the Attack}

\begin{lstlisting}[language=JavaScript]
const { solveHNP } = require('./lib/lattice.js');
const signatures = [ /* from generate-weak-sigs.js output */ ];
const candidates = solveHNP(signatures);
// candidates[0] contains the recovered private key
\end{lstlisting}

\section{Mathematical Details}

\subsection{Why 53-Bit Nonces Are Catastrophic}

For a secure ECDSA signature, the nonce $k$ should be uniformly distributed over $[1, n-1]$, providing $\log_2(n) \approx 256$ bits of entropy.

With a 53-bit nonce, the entropy is reduced to 53 bits. The HNP attack requires approximately $\frac{256}{53} \approx 5$ signatures for the lattice attack to succeed, though practical attacks require more due to error accumulation.

The key insight is that the nonce's most significant bits being zero creates a \textit{structured} search space. Rather than searching $2^{256}$ possible keys, we search combinations of:
\begin{itemize}
    \item $2^{53}$ possible nonces (for each signature)
    \item $\sim 2^{200}$ possible upper bits of $d$
\end{itemize}

The lattice structure collapses this exponential search to polynomial-time.

\subsection{Lattice Dimension Selection}

For $m$ signatures with $\ell$-bit known nonce leakage, the lattice dimension is $m + 2$. The gap between the target vector and shortest lattice vector determines success probability.

For 53-bit known lower bits on secp256k1:
\begin{itemize}
    \item Leakage per signature: 53 bits
    \item Target key size: 256 bits
    \item Recommended signatures: $\lceil 256 / 53 \rceil \cdot 2 = 10$
\end{itemize}

In practice, 15--20 signatures provide robust recovery accounting for noise.

\vspace{1cm}
\hrule
\vspace{0.5cm}
\textit{This paper is provided for educational and defensive security purposes. The authors do not advocate for unauthorized access to cryptographic systems.}

\end{document}